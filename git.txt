GIT

WHY use version control? PHDcomics image

Single user
- nothing is lost, can get back to earlier stage - e.g. useful to get back to previously working version of code.
- what version of code was used on day x to generate those results?
- sync multiple copies over different machines

Multiple users
- share latest version on a server - YOU decide on which version you want to work. Possible to work on a particular version while others work on other version, then merge.
- record of who made what change when
- conflict resolution


- mostly used for coding, but not only. Works with every kind of file, although things like file comparison works better with TEXT. LaTeX other good example. Data (small sets), etc.
EVERYTHING THAT CHANGES OVER TIME or NEEDS TO BE SHARED.


On its own, DOES NOT REPLACE BACKUP (unless 2nd copy)

It doesn’t require a server, unless sync and share are desired. Free GitHub provides server, no need to set one up. Community. Features for collaborative projects. Sharing.



FEATURES
- changes are saved sequentially
- forking: different versions can be saved separately
- merging: different versions can be merged - conflict resolution

TERMINOLOGY
- COMMIT -> user decides what changes make next version. NOT AUTOMATED
- REPOSITORY -> complete history of commits for particular project


1 - SETTING UP
Objectives:	- Configure git for the first time on a computer
		- Create a new repository



$ git config --global user.name “Thomas Guignard”
$ git config --global user.email “tom”@timtom.ch”   <- email will likt to GitHub
$ git config --global color.ui "auto"
$ git config --global core.editor "nano -w"

Explain what each of these are doing.
--global flag --> for every project on this computer. Also possible to have different settings for each directory (--local flag), etc. Type git config to get list of possible arguments.


Check

$ git config -l


Create a repository

We’re going to start a project about planets.

$ mkdir planets
$ cd planets

planets is going to be the root dir of our project. Let’s make it into a REPOSITORY

$ git init

See what’s been added with

$ ls -a

.git subdirectory contains everything git. Deleting it deletes all git data for that repo. Makes it easy to copy, replace, etc. or revert to simple directory.

Check status:
$ git status


2 - TRACKING CHANGES
Objectives:	- Go through modify-add-commit cycle for files
		- Explain commit workflow. Where is information stored.



Let’s create a file inside our repository:

$ nano mars.txt

Write some text

$ ls

What the status now?
$ git status

--> untracked file.

$ git add mars.txt  -> add to staging area
$ git status

--> new file

Now git know it’s supposed to keep track of mars.txt but HASN’T RECORDED CHANGES YET.

$ git commit -m "Start notes on Mars"

--> messages are REQUIRED. If omitted, editor will be launched.

Note unique idenfier.

$ git status

--> all is up to date

To get list of what we did so far:
$ git log

Now edit mars.txt some more.

$ git status

--> Git tells us there are changes but warns that nothing will happen. Messages usually helpful.

$ git diff
to get summary of changes

So now if I do
$ git commit -m “More notes on Mars.”

QQQ - 	All is set, right?
	How can I check?
	$ git status
	What’s wrong?
	How do I fix this?

	$git add mars.txt
		first

Why does git insist we add files manually all the time? We have complete control. We decide what to keep track? E.g. we don’t want to keep track of some doodles in another document.

We can use
$ git commit -a
To add AND commit at the same time.

Up to you.

STAGING AREA -> use git add to put stuff in the staging area - equiv. who goes on a group picture
COMMIT 	     -> use git commit to actually take a snapshot   - equiv. taking the picture
COMMIT -A    -> take snapshot of everything		     - equiv. take picture with other ppl


To illustrate differences
Use git diff
	- before staging
	- after staging
		Nothing because checks for differences between directory and what’s been asked to saved
		$ git diff --staged
			to check
	- after committing


$ git add mars.txt
$ git commit -m “More changes”

$ git log

QQQ -	Try to do some changes on your file, stage, and commit.
		Display changes
	Create a second file in the same repository, and include it as a tracked file.




3 - WORKING WITH HISTORY
Objectives:	- Use those commit numbers we’ve seen
		- Compare various versions
		- Restore old versions


Remember commit numbers?
$ git log

How can we see difference between current version of mars.txt and a previous one?

$ git diff f22b25e mars.txt
--> we can use whole 40 character hash but super annoying. So we can use first characters too. Enough so that it is unique.

Or get all differences if we have multiple files
$ git diff f22b25e


Annoying to type identifier. If we want to check the LATEST commit we can use HEAD~1 instead:
$ git diff HEAD~1 mars.txt

HEAD points to current commit. HEAD~1 is “head minus one”. HEAD~2 is “head minus two” etc.

So to compare the last two changes we can use
$ git diff HEAD~1 HEAD~2


OK so now we can see changes. How can we revert.

Say we make a mistake and overwrite one of our files:
$ nano mars.txt
	Replace current text.

If I use
$ git status

It tells us the file has been changed, but changes have not been staged yet.

To put things back how they were at last commit:
$ git checkout HEAD mars.txt

We can use commit identifiers instead of HEAD to go even further back.

$ git checkout f22b25e mars.txt

WARNING - we must use identifier of state BEFORE we made the change we’re trying to undo.

git status gives hints:

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)


QQQ -	Make some changes.
	How can I revert to previous status?
		$ git checkout HEAD
		$ git checkout HEAD mars.txt
		$ git checkout HEAD~1 mars.txt
		$ git checkout 2ddbf mars.txt
	(answer 2 and 4)

	Delete your file. Get it back.
	Get back to your first version.
	Get back to latest version.



4 - IGNORING THINGS
OBJECTIVES	- Configure git to ignore specific files
		- Why ignore files?

Your project will typically contain code AND data. Eg. results of your code. You typically don’t want to keep that -> waste of disk space (want to keep a copy every time you run your code??)

Let’s create some dummy results:
$ mkdir results
$ touch a.dat b.dat c.dat results/a.out results/b.out

$ git status

We can see all those new files. Other danger of keeping track of results files. Say you have large list of data files. Easy to overlook some other more important changes in git status.
So good practice not to keep track of them.

We can specify what stuff git should ignore by using special file:
$ nano .gitignore

In it, every line is something that needs to be ignored.
- Can be file names
- Or directories (trailing slash)
- Or patterns, e.g. *.dat

Now, let’s try again
$ git status

Cleaner. Note that, of course, git notifies us that there is a new file.

QQQ	- What shall we do?
	- Ignore it? How can we do it?
		- add .gitignore to .gitignore
	- Good idea? Why?
		Not necessarily. Usually a good thing to keep track of .gitignore.
		Useful when creating new copies of repository.

So:
$ git add .gitignore
$ git commit -m "Add the ignore file"
$ git status

.gitignore will prevent us from adding files we don’t want to track:
$ git add a.dat

-> we get a warning

We can still force git to override .gitignore:
$ git add -f

Or see status of ignored files:
$ git status --ignored

QQQ	- If not done already, add data files and ignore them.



5 - Adding a remote repo / GitHub
OBJECTIVES:	- What’s a remote repo? Why is it useful?
		- Clone remote repo
		- Push and Pull

How can we collaborate with others on repo? We could technically email each other files and add them to our own repos, etc. Much easier to have a central copy, keep it on the web, and sync with it. Useful for 1 person (backup, multiple computers, sharing) or for a team (collaboration).

Several services exist. You can even setup your own server. We will use GitHub here.

- Login to GitHub
- Create new repo
- Name repo --> CAN BE A DIFFERENT NAME than local

Now we have an empty repo on GitHub. Same situation as if we did
	$ mkdir planets
	$ cd planets
	$ git init
		on GitHub server.


To connect the two repositories:

$ git remote add origin https://github.com/vlad/planets

	- Switch from SSH to HTTPS
		SSH more secure but requires some more config.
	- Use copy button

Check:
$ git remote -v

‘origin’ is a nickname for your remote repo. Can use another, but this is most common. Can have multiple (useful when dealing with local forks).

We haven’t uploaded any files yet. To put the local changes on server: PUSH

$ git push origin master
		    ^-- this is the name of the branch. We’ll get to that.

	Most systems now use password managers. 
	Should have recognised your email address and password. 
	Otherwise will ask password. Can be unset:
	$ unset SSH_ASKPASS



QQQ	- Create GitHub account.
	- Create repository there.
	- Push your local data there
	- Look at results on GitHub
		- Can you see commit number?
		- How many commits? More than one? Why?
		- Notice timestamps?



What if I want to get data from remote to local, e.g. I’m syncing with work done by my team in the morning:
$ git pull origin master

In this case, nothing changes because up to date.




6 - COLLABORATING (if enough time)
OBJECTIVES:	- Collaborate by pushing to a common repository.

We’re going to use two different versions of same repo as example.
Same user, different copies. Case of syncing between computers.
Works the same if there were two different people.

CLONING a repo
 = creating a local copy of a remote

- Open another terminal window
- Create new directory and cd to it
- Look for clone URL on GitHub
$ git clone https://github.com/vlad/planets.git

Let’s make some changes in that copy

$ cd planets
$ nano pluto.txt

$ git add pluto.txt
$ git commit -m "Some notes about Pluto"

$ git status

Oh, and do we need to setup the remote?
$ git remote -v
-> already there! Taking over info when cloning, creating “origin” by default.

$ git push origin master

QQQ	- Which version is now the latest on the server?
	- On the right terminal? (other collaborator)
	- How do I get the new version on the right terminal?


		$ git pull origin master



7 - RESOLVING CONFLICTS
OBJECTIVES:	- What are conflicts? When do they occur?
		- How to resolve conflicts. MERGE



Previous example no conflict since 2nd collaborator created new file that wasn’t there in previous copy.

Let’s make a conflict by editing the mars.txt file

$ nano mars.txt
Make some changes.

Display mars.txt in both terminals to show difference.

Then push to GitHub:
$ git add mars.txt
$ git commit -m "Adding a line in LEFT copy”
$ git push origin master


Now let’s have the other partner make a change AT THE SAME TIME (without first pulling)


$ nano mars.txt
Make some changes.

Display mars.txt in both terminals to show difference.

Then push to GitHub:
$ git add mars.txt
$ git commit -m "Adding a line in RIGHT copy”
$ git push origin master


UH OH
What’s happening?
Git detects conflict. Not letting us overwrite previous version on server.

What we have to do is pull the changes from GitHub, MERGE and then push:

$ git pull origin master

Git warns us that there is a conflict. See what it has done to mars.txt:

$ nano mars.txt

Look for the special markers. It’s up to us to remove markers and fix changes.


$ git add mars.txt
$ git status

-> Git says conflicts are resolved but still need to MERGE.

$ git commit -m "Merging changes from GitHub"
$ git push origin master

Try doing 
$ git pull origin master
from other terminal window

We get the updated, corrected file. We don’t need to merge again, git knows someone’s already done it.

QQQ	- When working collaboratively, why is it a good idea to start pulling
	  before starting a new work session?
	- Try resolving conflicts using 2 copies. If enough time.
	- What happens if you have a conflict on an image file? How can we resolve?





8 - EXTRAS

- GUI tools. Show GitHub for Mac
	- List of repositories
	- Checkboxes --> staging
	- Commit and Sync at the same time
	- Editor shows changes
	- History tab --> equiv. git status

	To be used with GitHub (not really for local only)
	Can be used to create forks, branches, and pull requests

- Version control and GitHub as TOOLS FOR OPEN SCIENCE
	- Get feedback on code and data
	- Documents work, can resolve paternity issues
	- Other scientists can use same work
		(esp if paper also published in Open Access)
	- Others can check if results are reproducible
	- Code can be cited. GitHub can create DOIs for code.
	- Studies show, the more open work is, the more widely it is cited and reused.

- Good practices for sharing code
	- Include good README file
		Displayed prominently on GitHub
	- Add licensing and citation information to a project
		Include LICENSE file
		Include CITATION file
	- Choose proper license
		Code qualifies as intellectual property. 
		Shared code does not waive copyright protection.
		If no clear license, ppl who want to reuse don’t know what
			they can do. Could be illegal.
		Examples include
			- GNU General Public License GPL
				“infective”: any variation MUST be open as well
			- MIT
			- BSD
	- Licenses created for software are usually not usable for other stuff
		- Data. E.g. CC0 for public domain waiver
		- Creative works. Look at Creative Commons, eg. CC-BY and CC-BY-SA
	- Software Carpentry uses CC-BY for lessons and MIT for code.
	- REMEMBER: making data/code open does not mean waiving copyright. You still
	  own your stuff, you are still its creator. You just grant users the right
	  to use it in a certain way.
	- Hosting on public GitHub might not be a good idea depending on your research
		CHECK WITH INSTITUTION

- Mention branches
	See advanced Git lesson on Software Carpentry

